// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/stablecog/go-apps/database/ent/deviceinfo"
	"github.com/stablecog/go-apps/database/ent/generation"
	"github.com/stablecog/go-apps/database/ent/generationmodel"
	"github.com/stablecog/go-apps/database/ent/generationoutput"
	"github.com/stablecog/go-apps/database/ent/negativeprompt"
	"github.com/stablecog/go-apps/database/ent/predicate"
	"github.com/stablecog/go-apps/database/ent/prompt"
	"github.com/stablecog/go-apps/database/ent/scheduler"
	"github.com/stablecog/go-apps/database/ent/subscription"
	"github.com/stablecog/go-apps/database/ent/subscriptiontier"
	"github.com/stablecog/go-apps/database/ent/upscale"
	"github.com/stablecog/go-apps/database/ent/upscalemodel"
	"github.com/stablecog/go-apps/database/ent/upscaleoutput"
	"github.com/stablecog/go-apps/database/ent/user"
	"github.com/stablecog/go-apps/database/ent/userrole"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDeviceInfo       = "DeviceInfo"
	TypeGeneration       = "Generation"
	TypeGenerationModel  = "GenerationModel"
	TypeGenerationOutput = "GenerationOutput"
	TypeNegativePrompt   = "NegativePrompt"
	TypePrompt           = "Prompt"
	TypeScheduler        = "Scheduler"
	TypeSubscription     = "Subscription"
	TypeSubscriptionTier = "SubscriptionTier"
	TypeUpscale          = "Upscale"
	TypeUpscaleModel     = "UpscaleModel"
	TypeUpscaleOutput    = "UpscaleOutput"
	TypeUser             = "User"
	TypeUserRole         = "UserRole"
)

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	_type              *string
	os                 *string
	browser            *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	upscales           map[uuid.UUID]struct{}
	removedupscales    map[uuid.UUID]struct{}
	clearedupscales    bool
	done               bool
	oldValue           func(context.Context) (*DeviceInfo, error)
	predicates         []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id uuid.UUID) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *DeviceInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DeviceInfoMutation) ResetType() {
	m._type = nil
}

// SetOs sets the "os" field.
func (m *DeviceInfoMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *DeviceInfoMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *DeviceInfoMutation) ResetOs() {
	m.os = nil
}

// SetBrowser sets the "browser" field.
func (m *DeviceInfoMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *DeviceInfoMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldBrowser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ResetBrowser resets all changes to the "browser" field.
func (m *DeviceInfoMutation) ResetBrowser() {
	m.browser = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *DeviceInfoMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *DeviceInfoMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *DeviceInfoMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *DeviceInfoMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *DeviceInfoMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *DeviceInfoMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *DeviceInfoMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *DeviceInfoMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *DeviceInfoMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *DeviceInfoMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *DeviceInfoMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *DeviceInfoMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *DeviceInfoMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *DeviceInfoMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.os != nil {
		fields = append(fields, deviceinfo.FieldOs)
	}
	if m.browser != nil {
		fields = append(fields, deviceinfo.FieldBrowser)
	}
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldType:
		return m.GetType()
	case deviceinfo.FieldOs:
		return m.Os()
	case deviceinfo.FieldBrowser:
		return m.Browser()
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldType:
		return m.OldType(ctx)
	case deviceinfo.FieldOs:
		return m.OldOs(ctx)
	case deviceinfo.FieldBrowser:
		return m.OldBrowser(ctx)
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case deviceinfo.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case deviceinfo.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ResetType()
		return nil
	case deviceinfo.FieldOs:
		m.ResetOs()
		return nil
	case deviceinfo.FieldBrowser:
		m.ResetBrowser()
		return nil
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.generations != nil {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.upscales != nil {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgenerations != nil {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.removedupscales != nil {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgenerations {
		edges = append(edges, deviceinfo.EdgeGenerations)
	}
	if m.clearedupscales {
		edges = append(edges, deviceinfo.EdgeUpscales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinfo.EdgeGenerations:
		return m.clearedgenerations
	case deviceinfo.EdgeUpscales:
		return m.clearedupscales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	switch name {
	case deviceinfo.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case deviceinfo.EdgeUpscales:
		m.ResetUpscales()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// GenerationMutation represents an operation that mutates the Generation nodes in the graph.
type GenerationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	width                     *int32
	addwidth                  *int32
	height                    *int32
	addheight                 *int32
	num_interference_steps    *int32
	addnum_interference_steps *int32
	guidance_scale            *float32
	addguidance_scale         *float32
	seed                      *int
	addseed                   *int
	status                    *generation.Status
	failure_reason            *string
	country_code              *string
	gallery_status            *generation.GalleryStatus
	init_image_url            *string
	started_at                *time.Time
	completed_at              *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	device_info               *uuid.UUID
	cleareddevice_info        bool
	scheduler                 *uuid.UUID
	clearedscheduler          bool
	prompt                    *uuid.UUID
	clearedprompt             bool
	negative_prompt           *uuid.UUID
	clearednegative_prompt    bool
	generation_model          *uuid.UUID
	clearedgeneration_model   bool
	users                     *uuid.UUID
	clearedusers              bool
	generation_outputs        map[uuid.UUID]struct{}
	removedgeneration_outputs map[uuid.UUID]struct{}
	clearedgeneration_outputs bool
	done                      bool
	oldValue                  func(context.Context) (*Generation, error)
	predicates                []predicate.Generation
}

var _ ent.Mutation = (*GenerationMutation)(nil)

// generationOption allows management of the mutation configuration using functional options.
type generationOption func(*GenerationMutation)

// newGenerationMutation creates new mutation for the Generation entity.
func newGenerationMutation(c config, op Op, opts ...generationOption) *GenerationMutation {
	m := &GenerationMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationID sets the ID field of the mutation.
func withGenerationID(id uuid.UUID) generationOption {
	return func(m *GenerationMutation) {
		var (
			err   error
			once  sync.Once
			value *Generation
		)
		m.oldValue = func(ctx context.Context) (*Generation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Generation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneration sets the old Generation of the mutation.
func withGeneration(node *Generation) generationOption {
	return func(m *GenerationMutation) {
		m.oldValue = func(context.Context) (*Generation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Generation entities.
func (m *GenerationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Generation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWidth sets the "width" field.
func (m *GenerationMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *GenerationMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *GenerationMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *GenerationMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *GenerationMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *GenerationMutation) SetHeight(i int32) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *GenerationMutation) Height() (r int32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *GenerationMutation) AddHeight(i int32) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *GenerationMutation) AddedHeight() (r int32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *GenerationMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetNumInterferenceSteps sets the "num_interference_steps" field.
func (m *GenerationMutation) SetNumInterferenceSteps(i int32) {
	m.num_interference_steps = &i
	m.addnum_interference_steps = nil
}

// NumInterferenceSteps returns the value of the "num_interference_steps" field in the mutation.
func (m *GenerationMutation) NumInterferenceSteps() (r int32, exists bool) {
	v := m.num_interference_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldNumInterferenceSteps returns the old "num_interference_steps" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNumInterferenceSteps(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumInterferenceSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumInterferenceSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumInterferenceSteps: %w", err)
	}
	return oldValue.NumInterferenceSteps, nil
}

// AddNumInterferenceSteps adds i to the "num_interference_steps" field.
func (m *GenerationMutation) AddNumInterferenceSteps(i int32) {
	if m.addnum_interference_steps != nil {
		*m.addnum_interference_steps += i
	} else {
		m.addnum_interference_steps = &i
	}
}

// AddedNumInterferenceSteps returns the value that was added to the "num_interference_steps" field in this mutation.
func (m *GenerationMutation) AddedNumInterferenceSteps() (r int32, exists bool) {
	v := m.addnum_interference_steps
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumInterferenceSteps resets all changes to the "num_interference_steps" field.
func (m *GenerationMutation) ResetNumInterferenceSteps() {
	m.num_interference_steps = nil
	m.addnum_interference_steps = nil
}

// SetGuidanceScale sets the "guidance_scale" field.
func (m *GenerationMutation) SetGuidanceScale(f float32) {
	m.guidance_scale = &f
	m.addguidance_scale = nil
}

// GuidanceScale returns the value of the "guidance_scale" field in the mutation.
func (m *GenerationMutation) GuidanceScale() (r float32, exists bool) {
	v := m.guidance_scale
	if v == nil {
		return
	}
	return *v, true
}

// OldGuidanceScale returns the old "guidance_scale" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldGuidanceScale(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuidanceScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuidanceScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuidanceScale: %w", err)
	}
	return oldValue.GuidanceScale, nil
}

// AddGuidanceScale adds f to the "guidance_scale" field.
func (m *GenerationMutation) AddGuidanceScale(f float32) {
	if m.addguidance_scale != nil {
		*m.addguidance_scale += f
	} else {
		m.addguidance_scale = &f
	}
}

// AddedGuidanceScale returns the value that was added to the "guidance_scale" field in this mutation.
func (m *GenerationMutation) AddedGuidanceScale() (r float32, exists bool) {
	v := m.addguidance_scale
	if v == nil {
		return
	}
	return *v, true
}

// ResetGuidanceScale resets all changes to the "guidance_scale" field.
func (m *GenerationMutation) ResetGuidanceScale() {
	m.guidance_scale = nil
	m.addguidance_scale = nil
}

// SetSeed sets the "seed" field.
func (m *GenerationMutation) SetSeed(i int) {
	m.seed = &i
	m.addseed = nil
}

// Seed returns the value of the "seed" field in the mutation.
func (m *GenerationMutation) Seed() (r int, exists bool) {
	v := m.seed
	if v == nil {
		return
	}
	return *v, true
}

// OldSeed returns the old "seed" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeed: %w", err)
	}
	return oldValue.Seed, nil
}

// AddSeed adds i to the "seed" field.
func (m *GenerationMutation) AddSeed(i int) {
	if m.addseed != nil {
		*m.addseed += i
	} else {
		m.addseed = &i
	}
}

// AddedSeed returns the value that was added to the "seed" field in this mutation.
func (m *GenerationMutation) AddedSeed() (r int, exists bool) {
	v := m.addseed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeed resets all changes to the "seed" field.
func (m *GenerationMutation) ResetSeed() {
	m.seed = nil
	m.addseed = nil
}

// SetStatus sets the "status" field.
func (m *GenerationMutation) SetStatus(ge generation.Status) {
	m.status = &ge
}

// Status returns the value of the "status" field in the mutation.
func (m *GenerationMutation) Status() (r generation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldStatus(ctx context.Context) (v generation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GenerationMutation) ResetStatus() {
	m.status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *GenerationMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *GenerationMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *GenerationMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[generation.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *GenerationMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[generation.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *GenerationMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, generation.FieldFailureReason)
}

// SetCountryCode sets the "country_code" field.
func (m *GenerationMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *GenerationMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *GenerationMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetGalleryStatus sets the "gallery_status" field.
func (m *GenerationMutation) SetGalleryStatus(gs generation.GalleryStatus) {
	m.gallery_status = &gs
}

// GalleryStatus returns the value of the "gallery_status" field in the mutation.
func (m *GenerationMutation) GalleryStatus() (r generation.GalleryStatus, exists bool) {
	v := m.gallery_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGalleryStatus returns the old "gallery_status" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldGalleryStatus(ctx context.Context) (v generation.GalleryStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGalleryStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGalleryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGalleryStatus: %w", err)
	}
	return oldValue.GalleryStatus, nil
}

// ResetGalleryStatus resets all changes to the "gallery_status" field.
func (m *GenerationMutation) ResetGalleryStatus() {
	m.gallery_status = nil
}

// SetInitImageURL sets the "init_image_url" field.
func (m *GenerationMutation) SetInitImageURL(s string) {
	m.init_image_url = &s
}

// InitImageURL returns the value of the "init_image_url" field in the mutation.
func (m *GenerationMutation) InitImageURL() (r string, exists bool) {
	v := m.init_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInitImageURL returns the old "init_image_url" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldInitImageURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitImageURL: %w", err)
	}
	return oldValue.InitImageURL, nil
}

// ClearInitImageURL clears the value of the "init_image_url" field.
func (m *GenerationMutation) ClearInitImageURL() {
	m.init_image_url = nil
	m.clearedFields[generation.FieldInitImageURL] = struct{}{}
}

// InitImageURLCleared returns if the "init_image_url" field was cleared in this mutation.
func (m *GenerationMutation) InitImageURLCleared() bool {
	_, ok := m.clearedFields[generation.FieldInitImageURL]
	return ok
}

// ResetInitImageURL resets all changes to the "init_image_url" field.
func (m *GenerationMutation) ResetInitImageURL() {
	m.init_image_url = nil
	delete(m.clearedFields, generation.FieldInitImageURL)
}

// SetPromptID sets the "prompt_id" field.
func (m *GenerationMutation) SetPromptID(u uuid.UUID) {
	m.prompt = &u
}

// PromptID returns the value of the "prompt_id" field in the mutation.
func (m *GenerationMutation) PromptID() (r uuid.UUID, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptID returns the old "prompt_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldPromptID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptID: %w", err)
	}
	return oldValue.PromptID, nil
}

// ResetPromptID resets all changes to the "prompt_id" field.
func (m *GenerationMutation) ResetPromptID() {
	m.prompt = nil
}

// SetNegativePromptID sets the "negative_prompt_id" field.
func (m *GenerationMutation) SetNegativePromptID(u uuid.UUID) {
	m.negative_prompt = &u
}

// NegativePromptID returns the value of the "negative_prompt_id" field in the mutation.
func (m *GenerationMutation) NegativePromptID() (r uuid.UUID, exists bool) {
	v := m.negative_prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldNegativePromptID returns the old "negative_prompt_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldNegativePromptID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNegativePromptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNegativePromptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNegativePromptID: %w", err)
	}
	return oldValue.NegativePromptID, nil
}

// ClearNegativePromptID clears the value of the "negative_prompt_id" field.
func (m *GenerationMutation) ClearNegativePromptID() {
	m.negative_prompt = nil
	m.clearedFields[generation.FieldNegativePromptID] = struct{}{}
}

// NegativePromptIDCleared returns if the "negative_prompt_id" field was cleared in this mutation.
func (m *GenerationMutation) NegativePromptIDCleared() bool {
	_, ok := m.clearedFields[generation.FieldNegativePromptID]
	return ok
}

// ResetNegativePromptID resets all changes to the "negative_prompt_id" field.
func (m *GenerationMutation) ResetNegativePromptID() {
	m.negative_prompt = nil
	delete(m.clearedFields, generation.FieldNegativePromptID)
}

// SetModelID sets the "model_id" field.
func (m *GenerationMutation) SetModelID(u uuid.UUID) {
	m.generation_model = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *GenerationMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.generation_model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *GenerationMutation) ResetModelID() {
	m.generation_model = nil
}

// SetSchedulerID sets the "scheduler_id" field.
func (m *GenerationMutation) SetSchedulerID(u uuid.UUID) {
	m.scheduler = &u
}

// SchedulerID returns the value of the "scheduler_id" field in the mutation.
func (m *GenerationMutation) SchedulerID() (r uuid.UUID, exists bool) {
	v := m.scheduler
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedulerID returns the old "scheduler_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldSchedulerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedulerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedulerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedulerID: %w", err)
	}
	return oldValue.SchedulerID, nil
}

// ResetSchedulerID resets all changes to the "scheduler_id" field.
func (m *GenerationMutation) ResetSchedulerID() {
	m.scheduler = nil
}

// SetUserID sets the "user_id" field.
func (m *GenerationMutation) SetUserID(u uuid.UUID) {
	m.users = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GenerationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GenerationMutation) ResetUserID() {
	m.users = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *GenerationMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *GenerationMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *GenerationMutation) ResetDeviceInfoID() {
	m.device_info = nil
}

// SetStartedAt sets the "started_at" field.
func (m *GenerationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *GenerationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *GenerationMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[generation.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *GenerationMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[generation.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *GenerationMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, generation.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *GenerationMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *GenerationMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *GenerationMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[generation.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *GenerationMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[generation.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *GenerationMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, generation.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Generation entity.
// If the Generation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *GenerationMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *GenerationMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) DeviceInfoIDs() (ids []uuid.UUID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *GenerationMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// ClearScheduler clears the "scheduler" edge to the Scheduler entity.
func (m *GenerationMutation) ClearScheduler() {
	m.clearedscheduler = true
}

// SchedulerCleared reports if the "scheduler" edge to the Scheduler entity was cleared.
func (m *GenerationMutation) SchedulerCleared() bool {
	return m.clearedscheduler
}

// SchedulerIDs returns the "scheduler" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchedulerID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) SchedulerIDs() (ids []uuid.UUID) {
	if id := m.scheduler; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScheduler resets all changes to the "scheduler" edge.
func (m *GenerationMutation) ResetScheduler() {
	m.scheduler = nil
	m.clearedscheduler = false
}

// ClearPrompt clears the "prompt" edge to the Prompt entity.
func (m *GenerationMutation) ClearPrompt() {
	m.clearedprompt = true
}

// PromptCleared reports if the "prompt" edge to the Prompt entity was cleared.
func (m *GenerationMutation) PromptCleared() bool {
	return m.clearedprompt
}

// PromptIDs returns the "prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromptID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) PromptIDs() (ids []uuid.UUID) {
	if id := m.prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrompt resets all changes to the "prompt" edge.
func (m *GenerationMutation) ResetPrompt() {
	m.prompt = nil
	m.clearedprompt = false
}

// ClearNegativePrompt clears the "negative_prompt" edge to the NegativePrompt entity.
func (m *GenerationMutation) ClearNegativePrompt() {
	m.clearednegative_prompt = true
}

// NegativePromptCleared reports if the "negative_prompt" edge to the NegativePrompt entity was cleared.
func (m *GenerationMutation) NegativePromptCleared() bool {
	return m.NegativePromptIDCleared() || m.clearednegative_prompt
}

// NegativePromptIDs returns the "negative_prompt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NegativePromptID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) NegativePromptIDs() (ids []uuid.UUID) {
	if id := m.negative_prompt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNegativePrompt resets all changes to the "negative_prompt" edge.
func (m *GenerationMutation) ResetNegativePrompt() {
	m.negative_prompt = nil
	m.clearednegative_prompt = false
}

// SetGenerationModelID sets the "generation_model" edge to the GenerationModel entity by id.
func (m *GenerationMutation) SetGenerationModelID(id uuid.UUID) {
	m.generation_model = &id
}

// ClearGenerationModel clears the "generation_model" edge to the GenerationModel entity.
func (m *GenerationMutation) ClearGenerationModel() {
	m.clearedgeneration_model = true
}

// GenerationModelCleared reports if the "generation_model" edge to the GenerationModel entity was cleared.
func (m *GenerationMutation) GenerationModelCleared() bool {
	return m.clearedgeneration_model
}

// GenerationModelID returns the "generation_model" edge ID in the mutation.
func (m *GenerationMutation) GenerationModelID() (id uuid.UUID, exists bool) {
	if m.generation_model != nil {
		return *m.generation_model, true
	}
	return
}

// GenerationModelIDs returns the "generation_model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationModelID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) GenerationModelIDs() (ids []uuid.UUID) {
	if id := m.generation_model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerationModel resets all changes to the "generation_model" edge.
func (m *GenerationMutation) ResetGenerationModel() {
	m.generation_model = nil
	m.clearedgeneration_model = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *GenerationMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GenerationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GenerationMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *GenerationMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *GenerationMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GenerationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// AddGenerationOutputIDs adds the "generation_outputs" edge to the GenerationOutput entity by ids.
func (m *GenerationMutation) AddGenerationOutputIDs(ids ...uuid.UUID) {
	if m.generation_outputs == nil {
		m.generation_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generation_outputs[ids[i]] = struct{}{}
	}
}

// ClearGenerationOutputs clears the "generation_outputs" edge to the GenerationOutput entity.
func (m *GenerationMutation) ClearGenerationOutputs() {
	m.clearedgeneration_outputs = true
}

// GenerationOutputsCleared reports if the "generation_outputs" edge to the GenerationOutput entity was cleared.
func (m *GenerationMutation) GenerationOutputsCleared() bool {
	return m.clearedgeneration_outputs
}

// RemoveGenerationOutputIDs removes the "generation_outputs" edge to the GenerationOutput entity by IDs.
func (m *GenerationMutation) RemoveGenerationOutputIDs(ids ...uuid.UUID) {
	if m.removedgeneration_outputs == nil {
		m.removedgeneration_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generation_outputs, ids[i])
		m.removedgeneration_outputs[ids[i]] = struct{}{}
	}
}

// RemovedGenerationOutputs returns the removed IDs of the "generation_outputs" edge to the GenerationOutput entity.
func (m *GenerationMutation) RemovedGenerationOutputsIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneration_outputs {
		ids = append(ids, id)
	}
	return
}

// GenerationOutputsIDs returns the "generation_outputs" edge IDs in the mutation.
func (m *GenerationMutation) GenerationOutputsIDs() (ids []uuid.UUID) {
	for id := range m.generation_outputs {
		ids = append(ids, id)
	}
	return
}

// ResetGenerationOutputs resets all changes to the "generation_outputs" edge.
func (m *GenerationMutation) ResetGenerationOutputs() {
	m.generation_outputs = nil
	m.clearedgeneration_outputs = false
	m.removedgeneration_outputs = nil
}

// Where appends a list predicates to the GenerationMutation builder.
func (m *GenerationMutation) Where(ps ...predicate.Generation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Generation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Generation).
func (m *GenerationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.width != nil {
		fields = append(fields, generation.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, generation.FieldHeight)
	}
	if m.num_interference_steps != nil {
		fields = append(fields, generation.FieldNumInterferenceSteps)
	}
	if m.guidance_scale != nil {
		fields = append(fields, generation.FieldGuidanceScale)
	}
	if m.seed != nil {
		fields = append(fields, generation.FieldSeed)
	}
	if m.status != nil {
		fields = append(fields, generation.FieldStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, generation.FieldFailureReason)
	}
	if m.country_code != nil {
		fields = append(fields, generation.FieldCountryCode)
	}
	if m.gallery_status != nil {
		fields = append(fields, generation.FieldGalleryStatus)
	}
	if m.init_image_url != nil {
		fields = append(fields, generation.FieldInitImageURL)
	}
	if m.prompt != nil {
		fields = append(fields, generation.FieldPromptID)
	}
	if m.negative_prompt != nil {
		fields = append(fields, generation.FieldNegativePromptID)
	}
	if m.generation_model != nil {
		fields = append(fields, generation.FieldModelID)
	}
	if m.scheduler != nil {
		fields = append(fields, generation.FieldSchedulerID)
	}
	if m.users != nil {
		fields = append(fields, generation.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, generation.FieldDeviceInfoID)
	}
	if m.started_at != nil {
		fields = append(fields, generation.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, generation.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, generation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generation.FieldWidth:
		return m.Width()
	case generation.FieldHeight:
		return m.Height()
	case generation.FieldNumInterferenceSteps:
		return m.NumInterferenceSteps()
	case generation.FieldGuidanceScale:
		return m.GuidanceScale()
	case generation.FieldSeed:
		return m.Seed()
	case generation.FieldStatus:
		return m.Status()
	case generation.FieldFailureReason:
		return m.FailureReason()
	case generation.FieldCountryCode:
		return m.CountryCode()
	case generation.FieldGalleryStatus:
		return m.GalleryStatus()
	case generation.FieldInitImageURL:
		return m.InitImageURL()
	case generation.FieldPromptID:
		return m.PromptID()
	case generation.FieldNegativePromptID:
		return m.NegativePromptID()
	case generation.FieldModelID:
		return m.ModelID()
	case generation.FieldSchedulerID:
		return m.SchedulerID()
	case generation.FieldUserID:
		return m.UserID()
	case generation.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case generation.FieldStartedAt:
		return m.StartedAt()
	case generation.FieldCompletedAt:
		return m.CompletedAt()
	case generation.FieldCreatedAt:
		return m.CreatedAt()
	case generation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generation.FieldWidth:
		return m.OldWidth(ctx)
	case generation.FieldHeight:
		return m.OldHeight(ctx)
	case generation.FieldNumInterferenceSteps:
		return m.OldNumInterferenceSteps(ctx)
	case generation.FieldGuidanceScale:
		return m.OldGuidanceScale(ctx)
	case generation.FieldSeed:
		return m.OldSeed(ctx)
	case generation.FieldStatus:
		return m.OldStatus(ctx)
	case generation.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case generation.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case generation.FieldGalleryStatus:
		return m.OldGalleryStatus(ctx)
	case generation.FieldInitImageURL:
		return m.OldInitImageURL(ctx)
	case generation.FieldPromptID:
		return m.OldPromptID(ctx)
	case generation.FieldNegativePromptID:
		return m.OldNegativePromptID(ctx)
	case generation.FieldModelID:
		return m.OldModelID(ctx)
	case generation.FieldSchedulerID:
		return m.OldSchedulerID(ctx)
	case generation.FieldUserID:
		return m.OldUserID(ctx)
	case generation.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case generation.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case generation.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case generation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Generation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generation.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case generation.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case generation.FieldNumInterferenceSteps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumInterferenceSteps(v)
		return nil
	case generation.FieldGuidanceScale:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuidanceScale(v)
		return nil
	case generation.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeed(v)
		return nil
	case generation.FieldStatus:
		v, ok := value.(generation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generation.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case generation.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case generation.FieldGalleryStatus:
		v, ok := value.(generation.GalleryStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGalleryStatus(v)
		return nil
	case generation.FieldInitImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitImageURL(v)
		return nil
	case generation.FieldPromptID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptID(v)
		return nil
	case generation.FieldNegativePromptID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNegativePromptID(v)
		return nil
	case generation.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case generation.FieldSchedulerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedulerID(v)
		return nil
	case generation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case generation.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case generation.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case generation.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case generation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Generation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, generation.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, generation.FieldHeight)
	}
	if m.addnum_interference_steps != nil {
		fields = append(fields, generation.FieldNumInterferenceSteps)
	}
	if m.addguidance_scale != nil {
		fields = append(fields, generation.FieldGuidanceScale)
	}
	if m.addseed != nil {
		fields = append(fields, generation.FieldSeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generation.FieldWidth:
		return m.AddedWidth()
	case generation.FieldHeight:
		return m.AddedHeight()
	case generation.FieldNumInterferenceSteps:
		return m.AddedNumInterferenceSteps()
	case generation.FieldGuidanceScale:
		return m.AddedGuidanceScale()
	case generation.FieldSeed:
		return m.AddedSeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generation.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case generation.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case generation.FieldNumInterferenceSteps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumInterferenceSteps(v)
		return nil
	case generation.FieldGuidanceScale:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuidanceScale(v)
		return nil
	case generation.FieldSeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeed(v)
		return nil
	}
	return fmt.Errorf("unknown Generation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generation.FieldFailureReason) {
		fields = append(fields, generation.FieldFailureReason)
	}
	if m.FieldCleared(generation.FieldInitImageURL) {
		fields = append(fields, generation.FieldInitImageURL)
	}
	if m.FieldCleared(generation.FieldNegativePromptID) {
		fields = append(fields, generation.FieldNegativePromptID)
	}
	if m.FieldCleared(generation.FieldStartedAt) {
		fields = append(fields, generation.FieldStartedAt)
	}
	if m.FieldCleared(generation.FieldCompletedAt) {
		fields = append(fields, generation.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationMutation) ClearField(name string) error {
	switch name {
	case generation.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case generation.FieldInitImageURL:
		m.ClearInitImageURL()
		return nil
	case generation.FieldNegativePromptID:
		m.ClearNegativePromptID()
		return nil
	case generation.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case generation.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Generation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationMutation) ResetField(name string) error {
	switch name {
	case generation.FieldWidth:
		m.ResetWidth()
		return nil
	case generation.FieldHeight:
		m.ResetHeight()
		return nil
	case generation.FieldNumInterferenceSteps:
		m.ResetNumInterferenceSteps()
		return nil
	case generation.FieldGuidanceScale:
		m.ResetGuidanceScale()
		return nil
	case generation.FieldSeed:
		m.ResetSeed()
		return nil
	case generation.FieldStatus:
		m.ResetStatus()
		return nil
	case generation.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case generation.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case generation.FieldGalleryStatus:
		m.ResetGalleryStatus()
		return nil
	case generation.FieldInitImageURL:
		m.ResetInitImageURL()
		return nil
	case generation.FieldPromptID:
		m.ResetPromptID()
		return nil
	case generation.FieldNegativePromptID:
		m.ResetNegativePromptID()
		return nil
	case generation.FieldModelID:
		m.ResetModelID()
		return nil
	case generation.FieldSchedulerID:
		m.ResetSchedulerID()
		return nil
	case generation.FieldUserID:
		m.ResetUserID()
		return nil
	case generation.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case generation.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case generation.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case generation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Generation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.device_info != nil {
		edges = append(edges, generation.EdgeDeviceInfo)
	}
	if m.scheduler != nil {
		edges = append(edges, generation.EdgeScheduler)
	}
	if m.prompt != nil {
		edges = append(edges, generation.EdgePrompt)
	}
	if m.negative_prompt != nil {
		edges = append(edges, generation.EdgeNegativePrompt)
	}
	if m.generation_model != nil {
		edges = append(edges, generation.EdgeGenerationModel)
	}
	if m.users != nil {
		edges = append(edges, generation.EdgeUsers)
	}
	if m.generation_outputs != nil {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generation.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeScheduler:
		if id := m.scheduler; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgePrompt:
		if id := m.prompt; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeNegativePrompt:
		if id := m.negative_prompt; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeGenerationModel:
		if id := m.generation_model; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case generation.EdgeGenerationOutputs:
		ids := make([]ent.Value, 0, len(m.generation_outputs))
		for id := range m.generation_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedgeneration_outputs != nil {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generation.EdgeGenerationOutputs:
		ids := make([]ent.Value, 0, len(m.removedgeneration_outputs))
		for id := range m.removedgeneration_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareddevice_info {
		edges = append(edges, generation.EdgeDeviceInfo)
	}
	if m.clearedscheduler {
		edges = append(edges, generation.EdgeScheduler)
	}
	if m.clearedprompt {
		edges = append(edges, generation.EdgePrompt)
	}
	if m.clearednegative_prompt {
		edges = append(edges, generation.EdgeNegativePrompt)
	}
	if m.clearedgeneration_model {
		edges = append(edges, generation.EdgeGenerationModel)
	}
	if m.clearedusers {
		edges = append(edges, generation.EdgeUsers)
	}
	if m.clearedgeneration_outputs {
		edges = append(edges, generation.EdgeGenerationOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationMutation) EdgeCleared(name string) bool {
	switch name {
	case generation.EdgeDeviceInfo:
		return m.cleareddevice_info
	case generation.EdgeScheduler:
		return m.clearedscheduler
	case generation.EdgePrompt:
		return m.clearedprompt
	case generation.EdgeNegativePrompt:
		return m.clearednegative_prompt
	case generation.EdgeGenerationModel:
		return m.clearedgeneration_model
	case generation.EdgeUsers:
		return m.clearedusers
	case generation.EdgeGenerationOutputs:
		return m.clearedgeneration_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationMutation) ClearEdge(name string) error {
	switch name {
	case generation.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case generation.EdgeScheduler:
		m.ClearScheduler()
		return nil
	case generation.EdgePrompt:
		m.ClearPrompt()
		return nil
	case generation.EdgeNegativePrompt:
		m.ClearNegativePrompt()
		return nil
	case generation.EdgeGenerationModel:
		m.ClearGenerationModel()
		return nil
	case generation.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Generation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationMutation) ResetEdge(name string) error {
	switch name {
	case generation.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case generation.EdgeScheduler:
		m.ResetScheduler()
		return nil
	case generation.EdgePrompt:
		m.ResetPrompt()
		return nil
	case generation.EdgeNegativePrompt:
		m.ResetNegativePrompt()
		return nil
	case generation.EdgeGenerationModel:
		m.ResetGenerationModel()
		return nil
	case generation.EdgeUsers:
		m.ResetUsers()
		return nil
	case generation.EdgeGenerationOutputs:
		m.ResetGenerationOutputs()
		return nil
	}
	return fmt.Errorf("unknown Generation edge %s", name)
}

// GenerationModelMutation represents an operation that mutates the GenerationModel nodes in the graph.
type GenerationModelMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *string
	is_free            *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*GenerationModel, error)
	predicates         []predicate.GenerationModel
}

var _ ent.Mutation = (*GenerationModelMutation)(nil)

// generationmodelOption allows management of the mutation configuration using functional options.
type generationmodelOption func(*GenerationModelMutation)

// newGenerationModelMutation creates new mutation for the GenerationModel entity.
func newGenerationModelMutation(c config, op Op, opts ...generationmodelOption) *GenerationModelMutation {
	m := &GenerationModelMutation{
		config:        c,
		op:            op,
		typ:           TypeGenerationModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationModelID sets the ID field of the mutation.
func withGenerationModelID(id uuid.UUID) generationmodelOption {
	return func(m *GenerationModelMutation) {
		var (
			err   error
			once  sync.Once
			value *GenerationModel
		)
		m.oldValue = func(ctx context.Context) (*GenerationModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GenerationModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenerationModel sets the old GenerationModel of the mutation.
func withGenerationModel(node *GenerationModel) generationmodelOption {
	return func(m *GenerationModelMutation) {
		m.oldValue = func(context.Context) (*GenerationModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GenerationModel entities.
func (m *GenerationModelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationModelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationModelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GenerationModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GenerationModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GenerationModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GenerationModelMutation) ResetName() {
	m.name = nil
}

// SetIsFree sets the "is_free" field.
func (m *GenerationModelMutation) SetIsFree(b bool) {
	m.is_free = &b
}

// IsFree returns the value of the "is_free" field in the mutation.
func (m *GenerationModelMutation) IsFree() (r bool, exists bool) {
	v := m.is_free
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFree returns the old "is_free" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldIsFree(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFree: %w", err)
	}
	return oldValue.IsFree, nil
}

// ResetIsFree resets all changes to the "is_free" field.
func (m *GenerationModelMutation) ResetIsFree() {
	m.is_free = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GenerationModel entity.
// If the GenerationModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *GenerationModelMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *GenerationModelMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *GenerationModelMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *GenerationModelMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *GenerationModelMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *GenerationModelMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *GenerationModelMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the GenerationModelMutation builder.
func (m *GenerationModelMutation) Where(ps ...predicate.GenerationModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GenerationModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GenerationModel).
func (m *GenerationModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationModelMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, generationmodel.FieldName)
	}
	if m.is_free != nil {
		fields = append(fields, generationmodel.FieldIsFree)
	}
	if m.created_at != nil {
		fields = append(fields, generationmodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generationmodel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generationmodel.FieldName:
		return m.Name()
	case generationmodel.FieldIsFree:
		return m.IsFree()
	case generationmodel.FieldCreatedAt:
		return m.CreatedAt()
	case generationmodel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generationmodel.FieldName:
		return m.OldName(ctx)
	case generationmodel.FieldIsFree:
		return m.OldIsFree(ctx)
	case generationmodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generationmodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GenerationModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generationmodel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case generationmodel.FieldIsFree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFree(v)
		return nil
	case generationmodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generationmodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GenerationModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationModelMutation) ResetField(name string) error {
	switch name {
	case generationmodel.FieldName:
		m.ResetName()
		return nil
	case generationmodel.FieldIsFree:
		m.ResetIsFree()
		return nil
	case generationmodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generationmodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generationmodel.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generationmodel.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, generationmodel.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationModelMutation) EdgeCleared(name string) bool {
	switch name {
	case generationmodel.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationModelMutation) ResetEdge(name string) error {
	switch name {
	case generationmodel.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown GenerationModel edge %s", name)
}

// GenerationOutputMutation represents an operation that mutates the GenerationOutput nodes in the graph.
type GenerationOutputMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	image_url          *string
	upscaled_image_url *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        *uuid.UUID
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*GenerationOutput, error)
	predicates         []predicate.GenerationOutput
}

var _ ent.Mutation = (*GenerationOutputMutation)(nil)

// generationoutputOption allows management of the mutation configuration using functional options.
type generationoutputOption func(*GenerationOutputMutation)

// newGenerationOutputMutation creates new mutation for the GenerationOutput entity.
func newGenerationOutputMutation(c config, op Op, opts ...generationoutputOption) *GenerationOutputMutation {
	m := &GenerationOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeGenerationOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenerationOutputID sets the ID field of the mutation.
func withGenerationOutputID(id uuid.UUID) generationoutputOption {
	return func(m *GenerationOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *GenerationOutput
		)
		m.oldValue = func(ctx context.Context) (*GenerationOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GenerationOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenerationOutput sets the old GenerationOutput of the mutation.
func withGenerationOutput(node *GenerationOutput) generationoutputOption {
	return func(m *GenerationOutputMutation) {
		m.oldValue = func(context.Context) (*GenerationOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenerationOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenerationOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GenerationOutput entities.
func (m *GenerationOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenerationOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenerationOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GenerationOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImageURL sets the "image_url" field.
func (m *GenerationOutputMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *GenerationOutputMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *GenerationOutputMutation) ResetImageURL() {
	m.image_url = nil
}

// SetUpscaledImageURL sets the "upscaled_image_url" field.
func (m *GenerationOutputMutation) SetUpscaledImageURL(s string) {
	m.upscaled_image_url = &s
}

// UpscaledImageURL returns the value of the "upscaled_image_url" field in the mutation.
func (m *GenerationOutputMutation) UpscaledImageURL() (r string, exists bool) {
	v := m.upscaled_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldUpscaledImageURL returns the old "upscaled_image_url" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldUpscaledImageURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpscaledImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpscaledImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpscaledImageURL: %w", err)
	}
	return oldValue.UpscaledImageURL, nil
}

// ClearUpscaledImageURL clears the value of the "upscaled_image_url" field.
func (m *GenerationOutputMutation) ClearUpscaledImageURL() {
	m.upscaled_image_url = nil
	m.clearedFields[generationoutput.FieldUpscaledImageURL] = struct{}{}
}

// UpscaledImageURLCleared returns if the "upscaled_image_url" field was cleared in this mutation.
func (m *GenerationOutputMutation) UpscaledImageURLCleared() bool {
	_, ok := m.clearedFields[generationoutput.FieldUpscaledImageURL]
	return ok
}

// ResetUpscaledImageURL resets all changes to the "upscaled_image_url" field.
func (m *GenerationOutputMutation) ResetUpscaledImageURL() {
	m.upscaled_image_url = nil
	delete(m.clearedFields, generationoutput.FieldUpscaledImageURL)
}

// SetGenerationID sets the "generation_id" field.
func (m *GenerationOutputMutation) SetGenerationID(u uuid.UUID) {
	m.generations = &u
}

// GenerationID returns the value of the "generation_id" field in the mutation.
func (m *GenerationOutputMutation) GenerationID() (r uuid.UUID, exists bool) {
	v := m.generations
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerationID returns the old "generation_id" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldGenerationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerationID: %w", err)
	}
	return oldValue.GenerationID, nil
}

// ResetGenerationID resets all changes to the "generation_id" field.
func (m *GenerationOutputMutation) ResetGenerationID() {
	m.generations = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GenerationOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GenerationOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GenerationOutputMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GenerationOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GenerationOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GenerationOutput entity.
// If the GenerationOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenerationOutputMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GenerationOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGenerationsID sets the "generations" edge to the Generation entity by id.
func (m *GenerationOutputMutation) SetGenerationsID(id uuid.UUID) {
	m.generations = &id
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *GenerationOutputMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *GenerationOutputMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// GenerationsID returns the "generations" edge ID in the mutation.
func (m *GenerationOutputMutation) GenerationsID() (id uuid.UUID, exists bool) {
	if m.generations != nil {
		return *m.generations, true
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenerationsID instead. It exists only for internal usage by the builders.
func (m *GenerationOutputMutation) GenerationsIDs() (ids []uuid.UUID) {
	if id := m.generations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *GenerationOutputMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
}

// Where appends a list predicates to the GenerationOutputMutation builder.
func (m *GenerationOutputMutation) Where(ps ...predicate.GenerationOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenerationOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenerationOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GenerationOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenerationOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenerationOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GenerationOutput).
func (m *GenerationOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenerationOutputMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.image_url != nil {
		fields = append(fields, generationoutput.FieldImageURL)
	}
	if m.upscaled_image_url != nil {
		fields = append(fields, generationoutput.FieldUpscaledImageURL)
	}
	if m.generations != nil {
		fields = append(fields, generationoutput.FieldGenerationID)
	}
	if m.created_at != nil {
		fields = append(fields, generationoutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generationoutput.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenerationOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generationoutput.FieldImageURL:
		return m.ImageURL()
	case generationoutput.FieldUpscaledImageURL:
		return m.UpscaledImageURL()
	case generationoutput.FieldGenerationID:
		return m.GenerationID()
	case generationoutput.FieldCreatedAt:
		return m.CreatedAt()
	case generationoutput.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenerationOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generationoutput.FieldImageURL:
		return m.OldImageURL(ctx)
	case generationoutput.FieldUpscaledImageURL:
		return m.OldUpscaledImageURL(ctx)
	case generationoutput.FieldGenerationID:
		return m.OldGenerationID(ctx)
	case generationoutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generationoutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GenerationOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generationoutput.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case generationoutput.FieldUpscaledImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpscaledImageURL(v)
		return nil
	case generationoutput.FieldGenerationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerationID(v)
		return nil
	case generationoutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generationoutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenerationOutputMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenerationOutputMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenerationOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GenerationOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenerationOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generationoutput.FieldUpscaledImageURL) {
		fields = append(fields, generationoutput.FieldUpscaledImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenerationOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenerationOutputMutation) ClearField(name string) error {
	switch name {
	case generationoutput.FieldUpscaledImageURL:
		m.ClearUpscaledImageURL()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenerationOutputMutation) ResetField(name string) error {
	switch name {
	case generationoutput.FieldImageURL:
		m.ResetImageURL()
		return nil
	case generationoutput.FieldUpscaledImageURL:
		m.ResetUpscaledImageURL()
		return nil
	case generationoutput.FieldGenerationID:
		m.ResetGenerationID()
		return nil
	case generationoutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generationoutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenerationOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, generationoutput.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenerationOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generationoutput.EdgeGenerations:
		if id := m.generations; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenerationOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenerationOutputMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenerationOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, generationoutput.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenerationOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case generationoutput.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenerationOutputMutation) ClearEdge(name string) error {
	switch name {
	case generationoutput.EdgeGenerations:
		m.ClearGenerations()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenerationOutputMutation) ResetEdge(name string) error {
	switch name {
	case generationoutput.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown GenerationOutput edge %s", name)
}

// NegativePromptMutation represents an operation that mutates the NegativePrompt nodes in the graph.
type NegativePromptMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	text               *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*NegativePrompt, error)
	predicates         []predicate.NegativePrompt
}

var _ ent.Mutation = (*NegativePromptMutation)(nil)

// negativepromptOption allows management of the mutation configuration using functional options.
type negativepromptOption func(*NegativePromptMutation)

// newNegativePromptMutation creates new mutation for the NegativePrompt entity.
func newNegativePromptMutation(c config, op Op, opts ...negativepromptOption) *NegativePromptMutation {
	m := &NegativePromptMutation{
		config:        c,
		op:            op,
		typ:           TypeNegativePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNegativePromptID sets the ID field of the mutation.
func withNegativePromptID(id uuid.UUID) negativepromptOption {
	return func(m *NegativePromptMutation) {
		var (
			err   error
			once  sync.Once
			value *NegativePrompt
		)
		m.oldValue = func(ctx context.Context) (*NegativePrompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NegativePrompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNegativePrompt sets the old NegativePrompt of the mutation.
func withNegativePrompt(node *NegativePrompt) negativepromptOption {
	return func(m *NegativePromptMutation) {
		m.oldValue = func(context.Context) (*NegativePrompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NegativePromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NegativePromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NegativePrompt entities.
func (m *NegativePromptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NegativePromptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NegativePromptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NegativePrompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *NegativePromptMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NegativePromptMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NegativePromptMutation) ResetText() {
	m.text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NegativePromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NegativePromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NegativePromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NegativePromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NegativePromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NegativePrompt entity.
// If the NegativePrompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NegativePromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NegativePromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *NegativePromptMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *NegativePromptMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *NegativePromptMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *NegativePromptMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *NegativePromptMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *NegativePromptMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *NegativePromptMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the NegativePromptMutation builder.
func (m *NegativePromptMutation) Where(ps ...predicate.NegativePrompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NegativePromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NegativePromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NegativePrompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NegativePromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NegativePromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NegativePrompt).
func (m *NegativePromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NegativePromptMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.text != nil {
		fields = append(fields, negativeprompt.FieldText)
	}
	if m.created_at != nil {
		fields = append(fields, negativeprompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, negativeprompt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NegativePromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case negativeprompt.FieldText:
		return m.Text()
	case negativeprompt.FieldCreatedAt:
		return m.CreatedAt()
	case negativeprompt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NegativePromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case negativeprompt.FieldText:
		return m.OldText(ctx)
	case negativeprompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case negativeprompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NegativePrompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NegativePromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case negativeprompt.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case negativeprompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case negativeprompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NegativePromptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NegativePromptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NegativePromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NegativePrompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NegativePromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NegativePromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NegativePromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NegativePrompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NegativePromptMutation) ResetField(name string) error {
	switch name {
	case negativeprompt.FieldText:
		m.ResetText()
		return nil
	case negativeprompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case negativeprompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NegativePromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NegativePromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case negativeprompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NegativePromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NegativePromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case negativeprompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NegativePromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, negativeprompt.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NegativePromptMutation) EdgeCleared(name string) bool {
	switch name {
	case negativeprompt.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NegativePromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NegativePrompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NegativePromptMutation) ResetEdge(name string) error {
	switch name {
	case negativeprompt.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown NegativePrompt edge %s", name)
}

// PromptMutation represents an operation that mutates the Prompt nodes in the graph.
type PromptMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	text               *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*Prompt, error)
	predicates         []predicate.Prompt
}

var _ ent.Mutation = (*PromptMutation)(nil)

// promptOption allows management of the mutation configuration using functional options.
type promptOption func(*PromptMutation)

// newPromptMutation creates new mutation for the Prompt entity.
func newPromptMutation(c config, op Op, opts ...promptOption) *PromptMutation {
	m := &PromptMutation{
		config:        c,
		op:            op,
		typ:           TypePrompt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromptID sets the ID field of the mutation.
func withPromptID(id uuid.UUID) promptOption {
	return func(m *PromptMutation) {
		var (
			err   error
			once  sync.Once
			value *Prompt
		)
		m.oldValue = func(ctx context.Context) (*Prompt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prompt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrompt sets the old Prompt of the mutation.
func withPrompt(node *Prompt) promptOption {
	return func(m *PromptMutation) {
		m.oldValue = func(context.Context) (*Prompt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Prompt entities.
func (m *PromptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prompt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *PromptMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *PromptMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *PromptMutation) ResetText() {
	m.text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PromptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Prompt entity.
// If the Prompt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *PromptMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *PromptMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *PromptMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *PromptMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *PromptMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *PromptMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *PromptMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the PromptMutation builder.
func (m *PromptMutation) Where(ps ...predicate.Prompt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prompt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prompt).
func (m *PromptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromptMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.text != nil {
		fields = append(fields, prompt.FieldText)
	}
	if m.created_at != nil {
		fields = append(fields, prompt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prompt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prompt.FieldText:
		return m.Text()
	case prompt.FieldCreatedAt:
		return m.CreatedAt()
	case prompt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prompt.FieldText:
		return m.OldText(ctx)
	case prompt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prompt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Prompt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prompt.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case prompt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prompt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prompt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromptMutation) ResetField(name string) error {
	switch name {
	case prompt.FieldText:
		m.ResetText()
		return nil
	case prompt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prompt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Prompt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, prompt.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, prompt.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prompt.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, prompt.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromptMutation) EdgeCleared(name string) bool {
	switch name {
	case prompt.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromptMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prompt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromptMutation) ResetEdge(name string) error {
	switch name {
	case prompt.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown Prompt edge %s", name)
}

// SchedulerMutation represents an operation that mutates the Scheduler nodes in the graph.
type SchedulerMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *string
	is_free            *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	generations        map[uuid.UUID]struct{}
	removedgenerations map[uuid.UUID]struct{}
	clearedgenerations bool
	done               bool
	oldValue           func(context.Context) (*Scheduler, error)
	predicates         []predicate.Scheduler
}

var _ ent.Mutation = (*SchedulerMutation)(nil)

// schedulerOption allows management of the mutation configuration using functional options.
type schedulerOption func(*SchedulerMutation)

// newSchedulerMutation creates new mutation for the Scheduler entity.
func newSchedulerMutation(c config, op Op, opts ...schedulerOption) *SchedulerMutation {
	m := &SchedulerMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduler,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchedulerID sets the ID field of the mutation.
func withSchedulerID(id uuid.UUID) schedulerOption {
	return func(m *SchedulerMutation) {
		var (
			err   error
			once  sync.Once
			value *Scheduler
		)
		m.oldValue = func(ctx context.Context) (*Scheduler, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scheduler.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduler sets the old Scheduler of the mutation.
func withScheduler(node *Scheduler) schedulerOption {
	return func(m *SchedulerMutation) {
		m.oldValue = func(context.Context) (*Scheduler, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchedulerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchedulerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Scheduler entities.
func (m *SchedulerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchedulerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchedulerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scheduler.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SchedulerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchedulerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchedulerMutation) ResetName() {
	m.name = nil
}

// SetIsFree sets the "is_free" field.
func (m *SchedulerMutation) SetIsFree(b bool) {
	m.is_free = &b
}

// IsFree returns the value of the "is_free" field in the mutation.
func (m *SchedulerMutation) IsFree() (r bool, exists bool) {
	v := m.is_free
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFree returns the old "is_free" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldIsFree(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFree: %w", err)
	}
	return oldValue.IsFree, nil
}

// ResetIsFree resets all changes to the "is_free" field.
func (m *SchedulerMutation) ResetIsFree() {
	m.is_free = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SchedulerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SchedulerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SchedulerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SchedulerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SchedulerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Scheduler entity.
// If the Scheduler object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchedulerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SchedulerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *SchedulerMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *SchedulerMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *SchedulerMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *SchedulerMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *SchedulerMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *SchedulerMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *SchedulerMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// Where appends a list predicates to the SchedulerMutation builder.
func (m *SchedulerMutation) Where(ps ...predicate.Scheduler) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchedulerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchedulerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scheduler, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchedulerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchedulerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scheduler).
func (m *SchedulerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchedulerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, scheduler.FieldName)
	}
	if m.is_free != nil {
		fields = append(fields, scheduler.FieldIsFree)
	}
	if m.created_at != nil {
		fields = append(fields, scheduler.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scheduler.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchedulerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scheduler.FieldName:
		return m.Name()
	case scheduler.FieldIsFree:
		return m.IsFree()
	case scheduler.FieldCreatedAt:
		return m.CreatedAt()
	case scheduler.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchedulerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scheduler.FieldName:
		return m.OldName(ctx)
	case scheduler.FieldIsFree:
		return m.OldIsFree(ctx)
	case scheduler.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scheduler.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Scheduler field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchedulerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scheduler.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case scheduler.FieldIsFree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFree(v)
		return nil
	case scheduler.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scheduler.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Scheduler field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchedulerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchedulerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchedulerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scheduler numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchedulerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchedulerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchedulerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scheduler nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchedulerMutation) ResetField(name string) error {
	switch name {
	case scheduler.FieldName:
		m.ResetName()
		return nil
	case scheduler.FieldIsFree:
		m.ResetIsFree()
		return nil
	case scheduler.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scheduler.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Scheduler field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchedulerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.generations != nil {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchedulerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scheduler.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchedulerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgenerations != nil {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchedulerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scheduler.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchedulerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenerations {
		edges = append(edges, scheduler.EdgeGenerations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchedulerMutation) EdgeCleared(name string) bool {
	switch name {
	case scheduler.EdgeGenerations:
		return m.clearedgenerations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchedulerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scheduler unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchedulerMutation) ResetEdge(name string) error {
	switch name {
	case scheduler.EdgeGenerations:
		m.ResetGenerations()
		return nil
	}
	return fmt.Errorf("unknown Scheduler edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	paid_started_at          *time.Time
	paid_cancelled_at        *time.Time
	paid_expires_at          *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	user                     *uuid.UUID
	cleareduser              bool
	subscription_tier        *uuid.UUID
	clearedsubscription_tier bool
	done                     bool
	oldValue                 func(context.Context) (*Subscription, error)
	predicates               []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id uuid.UUID) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SubscriptionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SubscriptionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetSubscriptionTierID sets the "subscription_tier_id" field.
func (m *SubscriptionMutation) SetSubscriptionTierID(u uuid.UUID) {
	m.subscription_tier = &u
}

// SubscriptionTierID returns the value of the "subscription_tier_id" field in the mutation.
func (m *SubscriptionMutation) SubscriptionTierID() (r uuid.UUID, exists bool) {
	v := m.subscription_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionTierID returns the old "subscription_tier_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldSubscriptionTierID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionTierID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionTierID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionTierID: %w", err)
	}
	return oldValue.SubscriptionTierID, nil
}

// ResetSubscriptionTierID resets all changes to the "subscription_tier_id" field.
func (m *SubscriptionMutation) ResetSubscriptionTierID() {
	m.subscription_tier = nil
}

// SetPaidStartedAt sets the "paid_started_at" field.
func (m *SubscriptionMutation) SetPaidStartedAt(t time.Time) {
	m.paid_started_at = &t
}

// PaidStartedAt returns the value of the "paid_started_at" field in the mutation.
func (m *SubscriptionMutation) PaidStartedAt() (r time.Time, exists bool) {
	v := m.paid_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidStartedAt returns the old "paid_started_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPaidStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidStartedAt: %w", err)
	}
	return oldValue.PaidStartedAt, nil
}

// ClearPaidStartedAt clears the value of the "paid_started_at" field.
func (m *SubscriptionMutation) ClearPaidStartedAt() {
	m.paid_started_at = nil
	m.clearedFields[subscription.FieldPaidStartedAt] = struct{}{}
}

// PaidStartedAtCleared returns if the "paid_started_at" field was cleared in this mutation.
func (m *SubscriptionMutation) PaidStartedAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldPaidStartedAt]
	return ok
}

// ResetPaidStartedAt resets all changes to the "paid_started_at" field.
func (m *SubscriptionMutation) ResetPaidStartedAt() {
	m.paid_started_at = nil
	delete(m.clearedFields, subscription.FieldPaidStartedAt)
}

// SetPaidCancelledAt sets the "paid_cancelled_at" field.
func (m *SubscriptionMutation) SetPaidCancelledAt(t time.Time) {
	m.paid_cancelled_at = &t
}

// PaidCancelledAt returns the value of the "paid_cancelled_at" field in the mutation.
func (m *SubscriptionMutation) PaidCancelledAt() (r time.Time, exists bool) {
	v := m.paid_cancelled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidCancelledAt returns the old "paid_cancelled_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPaidCancelledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidCancelledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidCancelledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidCancelledAt: %w", err)
	}
	return oldValue.PaidCancelledAt, nil
}

// ClearPaidCancelledAt clears the value of the "paid_cancelled_at" field.
func (m *SubscriptionMutation) ClearPaidCancelledAt() {
	m.paid_cancelled_at = nil
	m.clearedFields[subscription.FieldPaidCancelledAt] = struct{}{}
}

// PaidCancelledAtCleared returns if the "paid_cancelled_at" field was cleared in this mutation.
func (m *SubscriptionMutation) PaidCancelledAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldPaidCancelledAt]
	return ok
}

// ResetPaidCancelledAt resets all changes to the "paid_cancelled_at" field.
func (m *SubscriptionMutation) ResetPaidCancelledAt() {
	m.paid_cancelled_at = nil
	delete(m.clearedFields, subscription.FieldPaidCancelledAt)
}

// SetPaidExpiresAt sets the "paid_expires_at" field.
func (m *SubscriptionMutation) SetPaidExpiresAt(t time.Time) {
	m.paid_expires_at = &t
}

// PaidExpiresAt returns the value of the "paid_expires_at" field in the mutation.
func (m *SubscriptionMutation) PaidExpiresAt() (r time.Time, exists bool) {
	v := m.paid_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidExpiresAt returns the old "paid_expires_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldPaidExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidExpiresAt: %w", err)
	}
	return oldValue.PaidExpiresAt, nil
}

// ClearPaidExpiresAt clears the value of the "paid_expires_at" field.
func (m *SubscriptionMutation) ClearPaidExpiresAt() {
	m.paid_expires_at = nil
	m.clearedFields[subscription.FieldPaidExpiresAt] = struct{}{}
}

// PaidExpiresAtCleared returns if the "paid_expires_at" field was cleared in this mutation.
func (m *SubscriptionMutation) PaidExpiresAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldPaidExpiresAt]
	return ok
}

// ResetPaidExpiresAt resets all changes to the "paid_expires_at" field.
func (m *SubscriptionMutation) ResetPaidExpiresAt() {
	m.paid_expires_at = nil
	delete(m.clearedFields, subscription.FieldPaidExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubscriptionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearSubscriptionTier clears the "subscription_tier" edge to the SubscriptionTier entity.
func (m *SubscriptionMutation) ClearSubscriptionTier() {
	m.clearedsubscription_tier = true
}

// SubscriptionTierCleared reports if the "subscription_tier" edge to the SubscriptionTier entity was cleared.
func (m *SubscriptionMutation) SubscriptionTierCleared() bool {
	return m.clearedsubscription_tier
}

// SubscriptionTierIDs returns the "subscription_tier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionTierID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) SubscriptionTierIDs() (ids []uuid.UUID) {
	if id := m.subscription_tier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptionTier resets all changes to the "subscription_tier" edge.
func (m *SubscriptionMutation) ResetSubscriptionTier() {
	m.subscription_tier = nil
	m.clearedsubscription_tier = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, subscription.FieldUserID)
	}
	if m.subscription_tier != nil {
		fields = append(fields, subscription.FieldSubscriptionTierID)
	}
	if m.paid_started_at != nil {
		fields = append(fields, subscription.FieldPaidStartedAt)
	}
	if m.paid_cancelled_at != nil {
		fields = append(fields, subscription.FieldPaidCancelledAt)
	}
	if m.paid_expires_at != nil {
		fields = append(fields, subscription.FieldPaidExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldUserID:
		return m.UserID()
	case subscription.FieldSubscriptionTierID:
		return m.SubscriptionTierID()
	case subscription.FieldPaidStartedAt:
		return m.PaidStartedAt()
	case subscription.FieldPaidCancelledAt:
		return m.PaidCancelledAt()
	case subscription.FieldPaidExpiresAt:
		return m.PaidExpiresAt()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldUserID:
		return m.OldUserID(ctx)
	case subscription.FieldSubscriptionTierID:
		return m.OldSubscriptionTierID(ctx)
	case subscription.FieldPaidStartedAt:
		return m.OldPaidStartedAt(ctx)
	case subscription.FieldPaidCancelledAt:
		return m.OldPaidCancelledAt(ctx)
	case subscription.FieldPaidExpiresAt:
		return m.OldPaidExpiresAt(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case subscription.FieldSubscriptionTierID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionTierID(v)
		return nil
	case subscription.FieldPaidStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidStartedAt(v)
		return nil
	case subscription.FieldPaidCancelledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidCancelledAt(v)
		return nil
	case subscription.FieldPaidExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidExpiresAt(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldPaidStartedAt) {
		fields = append(fields, subscription.FieldPaidStartedAt)
	}
	if m.FieldCleared(subscription.FieldPaidCancelledAt) {
		fields = append(fields, subscription.FieldPaidCancelledAt)
	}
	if m.FieldCleared(subscription.FieldPaidExpiresAt) {
		fields = append(fields, subscription.FieldPaidExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldPaidStartedAt:
		m.ClearPaidStartedAt()
		return nil
	case subscription.FieldPaidCancelledAt:
		m.ClearPaidCancelledAt()
		return nil
	case subscription.FieldPaidExpiresAt:
		m.ClearPaidExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldUserID:
		m.ResetUserID()
		return nil
	case subscription.FieldSubscriptionTierID:
		m.ResetSubscriptionTierID()
		return nil
	case subscription.FieldPaidStartedAt:
		m.ResetPaidStartedAt()
		return nil
	case subscription.FieldPaidCancelledAt:
		m.ResetPaidCancelledAt()
		return nil
	case subscription.FieldPaidExpiresAt:
		m.ResetPaidExpiresAt()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.subscription_tier != nil {
		edges = append(edges, subscription.EdgeSubscriptionTier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgeSubscriptionTier:
		if id := m.subscription_tier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.clearedsubscription_tier {
		edges = append(edges, subscription.EdgeSubscriptionTier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeUser:
		return m.cleareduser
	case subscription.EdgeSubscriptionTier:
		return m.clearedsubscription_tier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ClearUser()
		return nil
	case subscription.EdgeSubscriptionTier:
		m.ClearSubscriptionTier()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ResetUser()
		return nil
	case subscription.EdgeSubscriptionTier:
		m.ResetSubscriptionTier()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// SubscriptionTierMutation represents an operation that mutates the SubscriptionTier nodes in the graph.
type SubscriptionTierMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	base_credits         *int32
	addbase_credits      *int32
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	subscriptions        map[uuid.UUID]struct{}
	removedsubscriptions map[uuid.UUID]struct{}
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*SubscriptionTier, error)
	predicates           []predicate.SubscriptionTier
}

var _ ent.Mutation = (*SubscriptionTierMutation)(nil)

// subscriptiontierOption allows management of the mutation configuration using functional options.
type subscriptiontierOption func(*SubscriptionTierMutation)

// newSubscriptionTierMutation creates new mutation for the SubscriptionTier entity.
func newSubscriptionTierMutation(c config, op Op, opts ...subscriptiontierOption) *SubscriptionTierMutation {
	m := &SubscriptionTierMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionTier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionTierID sets the ID field of the mutation.
func withSubscriptionTierID(id uuid.UUID) subscriptiontierOption {
	return func(m *SubscriptionTierMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionTier
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionTier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionTier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionTier sets the old SubscriptionTier of the mutation.
func withSubscriptionTier(node *SubscriptionTier) subscriptiontierOption {
	return func(m *SubscriptionTierMutation) {
		m.oldValue = func(context.Context) (*SubscriptionTier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionTierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionTierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubscriptionTier entities.
func (m *SubscriptionTierMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionTierMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionTierMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscriptionTier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SubscriptionTierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscriptionTierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubscriptionTier entity.
// If the SubscriptionTier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubscriptionTierMutation) ResetName() {
	m.name = nil
}

// SetBaseCredits sets the "base_credits" field.
func (m *SubscriptionTierMutation) SetBaseCredits(i int32) {
	m.base_credits = &i
	m.addbase_credits = nil
}

// BaseCredits returns the value of the "base_credits" field in the mutation.
func (m *SubscriptionTierMutation) BaseCredits() (r int32, exists bool) {
	v := m.base_credits
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCredits returns the old "base_credits" field's value of the SubscriptionTier entity.
// If the SubscriptionTier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTierMutation) OldBaseCredits(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCredits: %w", err)
	}
	return oldValue.BaseCredits, nil
}

// AddBaseCredits adds i to the "base_credits" field.
func (m *SubscriptionTierMutation) AddBaseCredits(i int32) {
	if m.addbase_credits != nil {
		*m.addbase_credits += i
	} else {
		m.addbase_credits = &i
	}
}

// AddedBaseCredits returns the value that was added to the "base_credits" field in this mutation.
func (m *SubscriptionTierMutation) AddedBaseCredits() (r int32, exists bool) {
	v := m.addbase_credits
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseCredits resets all changes to the "base_credits" field.
func (m *SubscriptionTierMutation) ResetBaseCredits() {
	m.base_credits = nil
	m.addbase_credits = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionTierMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionTierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscriptionTier entity.
// If the SubscriptionTier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionTierMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionTierMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionTierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscriptionTier entity.
// If the SubscriptionTier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionTierMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *SubscriptionTierMutation) AddSubscriptionIDs(ids ...uuid.UUID) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *SubscriptionTierMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *SubscriptionTierMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *SubscriptionTierMutation) RemoveSubscriptionIDs(ids ...uuid.UUID) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *SubscriptionTierMutation) RemovedSubscriptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *SubscriptionTierMutation) SubscriptionsIDs() (ids []uuid.UUID) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *SubscriptionTierMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// Where appends a list predicates to the SubscriptionTierMutation builder.
func (m *SubscriptionTierMutation) Where(ps ...predicate.SubscriptionTier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionTierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionTierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscriptionTier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionTierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionTierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscriptionTier).
func (m *SubscriptionTierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionTierMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, subscriptiontier.FieldName)
	}
	if m.base_credits != nil {
		fields = append(fields, subscriptiontier.FieldBaseCredits)
	}
	if m.created_at != nil {
		fields = append(fields, subscriptiontier.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriptiontier.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionTierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptiontier.FieldName:
		return m.Name()
	case subscriptiontier.FieldBaseCredits:
		return m.BaseCredits()
	case subscriptiontier.FieldCreatedAt:
		return m.CreatedAt()
	case subscriptiontier.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionTierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptiontier.FieldName:
		return m.OldName(ctx)
	case subscriptiontier.FieldBaseCredits:
		return m.OldBaseCredits(ctx)
	case subscriptiontier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriptiontier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionTier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionTierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptiontier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscriptiontier.FieldBaseCredits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCredits(v)
		return nil
	case subscriptiontier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriptiontier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionTier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionTierMutation) AddedFields() []string {
	var fields []string
	if m.addbase_credits != nil {
		fields = append(fields, subscriptiontier.FieldBaseCredits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionTierMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscriptiontier.FieldBaseCredits:
		return m.AddedBaseCredits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionTierMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscriptiontier.FieldBaseCredits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseCredits(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionTier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionTierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionTierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionTierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubscriptionTier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionTierMutation) ResetField(name string) error {
	switch name {
	case subscriptiontier.FieldName:
		m.ResetName()
		return nil
	case subscriptiontier.FieldBaseCredits:
		m.ResetBaseCredits()
		return nil
	case subscriptiontier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriptiontier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionTier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionTierMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subscriptions != nil {
		edges = append(edges, subscriptiontier.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionTierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptiontier.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionTierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubscriptions != nil {
		edges = append(edges, subscriptiontier.EdgeSubscriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionTierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscriptiontier.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionTierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubscriptions {
		edges = append(edges, subscriptiontier.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionTierMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptiontier.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionTierMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionTier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionTierMutation) ResetEdge(name string) error {
	switch name {
	case subscriptiontier.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionTier edge %s", name)
}

// UpscaleMutation represents an operation that mutates the Upscale nodes in the graph.
type UpscaleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	width                  *int32
	addwidth               *int32
	height                 *int32
	addheight              *int32
	scale                  *int32
	addscale               *int32
	duration_ms            *int32
	addduration_ms         *int32
	country_code           *string
	status                 *upscale.Status
	failure_reason         *string
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *uuid.UUID
	cleareduser            bool
	device_info            *uuid.UUID
	cleareddevice_info     bool
	upscale_models         *uuid.UUID
	clearedupscale_models  bool
	upscale_outputs        map[uuid.UUID]struct{}
	removedupscale_outputs map[uuid.UUID]struct{}
	clearedupscale_outputs bool
	done                   bool
	oldValue               func(context.Context) (*Upscale, error)
	predicates             []predicate.Upscale
}

var _ ent.Mutation = (*UpscaleMutation)(nil)

// upscaleOption allows management of the mutation configuration using functional options.
type upscaleOption func(*UpscaleMutation)

// newUpscaleMutation creates new mutation for the Upscale entity.
func newUpscaleMutation(c config, op Op, opts ...upscaleOption) *UpscaleMutation {
	m := &UpscaleMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscale,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleID sets the ID field of the mutation.
func withUpscaleID(id uuid.UUID) upscaleOption {
	return func(m *UpscaleMutation) {
		var (
			err   error
			once  sync.Once
			value *Upscale
		)
		m.oldValue = func(ctx context.Context) (*Upscale, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Upscale.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscale sets the old Upscale of the mutation.
func withUpscale(node *Upscale) upscaleOption {
	return func(m *UpscaleMutation) {
		m.oldValue = func(context.Context) (*Upscale, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Upscale entities.
func (m *UpscaleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Upscale.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWidth sets the "width" field.
func (m *UpscaleMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *UpscaleMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *UpscaleMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *UpscaleMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *UpscaleMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *UpscaleMutation) SetHeight(i int32) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *UpscaleMutation) Height() (r int32, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldHeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *UpscaleMutation) AddHeight(i int32) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *UpscaleMutation) AddedHeight() (r int32, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *UpscaleMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetScale sets the "scale" field.
func (m *UpscaleMutation) SetScale(i int32) {
	m.scale = &i
	m.addscale = nil
}

// Scale returns the value of the "scale" field in the mutation.
func (m *UpscaleMutation) Scale() (r int32, exists bool) {
	v := m.scale
	if v == nil {
		return
	}
	return *v, true
}

// OldScale returns the old "scale" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldScale(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScale: %w", err)
	}
	return oldValue.Scale, nil
}

// AddScale adds i to the "scale" field.
func (m *UpscaleMutation) AddScale(i int32) {
	if m.addscale != nil {
		*m.addscale += i
	} else {
		m.addscale = &i
	}
}

// AddedScale returns the value that was added to the "scale" field in this mutation.
func (m *UpscaleMutation) AddedScale() (r int32, exists bool) {
	v := m.addscale
	if v == nil {
		return
	}
	return *v, true
}

// ResetScale resets all changes to the "scale" field.
func (m *UpscaleMutation) ResetScale() {
	m.scale = nil
	m.addscale = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *UpscaleMutation) SetDurationMs(i int32) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *UpscaleMutation) DurationMs() (r int32, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldDurationMs(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *UpscaleMutation) AddDurationMs(i int32) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *UpscaleMutation) AddedDurationMs() (r int32, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *UpscaleMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
}

// SetCountryCode sets the "country_code" field.
func (m *UpscaleMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *UpscaleMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *UpscaleMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetStatus sets the "status" field.
func (m *UpscaleMutation) SetStatus(u upscale.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UpscaleMutation) Status() (r upscale.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldStatus(ctx context.Context) (v upscale.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UpscaleMutation) ResetStatus() {
	m.status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *UpscaleMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *UpscaleMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *UpscaleMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[upscale.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *UpscaleMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[upscale.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *UpscaleMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, upscale.FieldFailureReason)
}

// SetUserID sets the "user_id" field.
func (m *UpscaleMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UpscaleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UpscaleMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *UpscaleMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *UpscaleMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *UpscaleMutation) ResetDeviceInfoID() {
	m.device_info = nil
}

// SetModelID sets the "model_id" field.
func (m *UpscaleMutation) SetModelID(u uuid.UUID) {
	m.upscale_models = &u
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UpscaleMutation) ModelID() (r uuid.UUID, exists bool) {
	v := m.upscale_models
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldModelID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UpscaleMutation) ResetModelID() {
	m.upscale_models = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Upscale entity.
// If the Upscale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UpscaleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UpscaleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UpscaleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UpscaleMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UpscaleMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) DeviceInfoIDs() (ids []uuid.UUID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UpscaleMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// SetUpscaleModelsID sets the "upscale_models" edge to the UpscaleModel entity by id.
func (m *UpscaleMutation) SetUpscaleModelsID(id uuid.UUID) {
	m.upscale_models = &id
}

// ClearUpscaleModels clears the "upscale_models" edge to the UpscaleModel entity.
func (m *UpscaleMutation) ClearUpscaleModels() {
	m.clearedupscale_models = true
}

// UpscaleModelsCleared reports if the "upscale_models" edge to the UpscaleModel entity was cleared.
func (m *UpscaleMutation) UpscaleModelsCleared() bool {
	return m.clearedupscale_models
}

// UpscaleModelsID returns the "upscale_models" edge ID in the mutation.
func (m *UpscaleMutation) UpscaleModelsID() (id uuid.UUID, exists bool) {
	if m.upscale_models != nil {
		return *m.upscale_models, true
	}
	return
}

// UpscaleModelsIDs returns the "upscale_models" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscaleModelsID instead. It exists only for internal usage by the builders.
func (m *UpscaleMutation) UpscaleModelsIDs() (ids []uuid.UUID) {
	if id := m.upscale_models; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscaleModels resets all changes to the "upscale_models" edge.
func (m *UpscaleMutation) ResetUpscaleModels() {
	m.upscale_models = nil
	m.clearedupscale_models = false
}

// AddUpscaleOutputIDs adds the "upscale_outputs" edge to the UpscaleOutput entity by ids.
func (m *UpscaleMutation) AddUpscaleOutputIDs(ids ...uuid.UUID) {
	if m.upscale_outputs == nil {
		m.upscale_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscale_outputs[ids[i]] = struct{}{}
	}
}

// ClearUpscaleOutputs clears the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *UpscaleMutation) ClearUpscaleOutputs() {
	m.clearedupscale_outputs = true
}

// UpscaleOutputsCleared reports if the "upscale_outputs" edge to the UpscaleOutput entity was cleared.
func (m *UpscaleMutation) UpscaleOutputsCleared() bool {
	return m.clearedupscale_outputs
}

// RemoveUpscaleOutputIDs removes the "upscale_outputs" edge to the UpscaleOutput entity by IDs.
func (m *UpscaleMutation) RemoveUpscaleOutputIDs(ids ...uuid.UUID) {
	if m.removedupscale_outputs == nil {
		m.removedupscale_outputs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscale_outputs, ids[i])
		m.removedupscale_outputs[ids[i]] = struct{}{}
	}
}

// RemovedUpscaleOutputs returns the removed IDs of the "upscale_outputs" edge to the UpscaleOutput entity.
func (m *UpscaleMutation) RemovedUpscaleOutputsIDs() (ids []uuid.UUID) {
	for id := range m.removedupscale_outputs {
		ids = append(ids, id)
	}
	return
}

// UpscaleOutputsIDs returns the "upscale_outputs" edge IDs in the mutation.
func (m *UpscaleMutation) UpscaleOutputsIDs() (ids []uuid.UUID) {
	for id := range m.upscale_outputs {
		ids = append(ids, id)
	}
	return
}

// ResetUpscaleOutputs resets all changes to the "upscale_outputs" edge.
func (m *UpscaleMutation) ResetUpscaleOutputs() {
	m.upscale_outputs = nil
	m.clearedupscale_outputs = false
	m.removedupscale_outputs = nil
}

// Where appends a list predicates to the UpscaleMutation builder.
func (m *UpscaleMutation) Where(ps ...predicate.Upscale) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Upscale, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Upscale).
func (m *UpscaleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.width != nil {
		fields = append(fields, upscale.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, upscale.FieldHeight)
	}
	if m.scale != nil {
		fields = append(fields, upscale.FieldScale)
	}
	if m.duration_ms != nil {
		fields = append(fields, upscale.FieldDurationMs)
	}
	if m.country_code != nil {
		fields = append(fields, upscale.FieldCountryCode)
	}
	if m.status != nil {
		fields = append(fields, upscale.FieldStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, upscale.FieldFailureReason)
	}
	if m.user != nil {
		fields = append(fields, upscale.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, upscale.FieldDeviceInfoID)
	}
	if m.upscale_models != nil {
		fields = append(fields, upscale.FieldModelID)
	}
	if m.created_at != nil {
		fields = append(fields, upscale.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscale.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscale.FieldWidth:
		return m.Width()
	case upscale.FieldHeight:
		return m.Height()
	case upscale.FieldScale:
		return m.Scale()
	case upscale.FieldDurationMs:
		return m.DurationMs()
	case upscale.FieldCountryCode:
		return m.CountryCode()
	case upscale.FieldStatus:
		return m.Status()
	case upscale.FieldFailureReason:
		return m.FailureReason()
	case upscale.FieldUserID:
		return m.UserID()
	case upscale.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case upscale.FieldModelID:
		return m.ModelID()
	case upscale.FieldCreatedAt:
		return m.CreatedAt()
	case upscale.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscale.FieldWidth:
		return m.OldWidth(ctx)
	case upscale.FieldHeight:
		return m.OldHeight(ctx)
	case upscale.FieldScale:
		return m.OldScale(ctx)
	case upscale.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case upscale.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case upscale.FieldStatus:
		return m.OldStatus(ctx)
	case upscale.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case upscale.FieldUserID:
		return m.OldUserID(ctx)
	case upscale.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case upscale.FieldModelID:
		return m.OldModelID(ctx)
	case upscale.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscale.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Upscale field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscale.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case upscale.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case upscale.FieldScale:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScale(v)
		return nil
	case upscale.FieldDurationMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case upscale.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case upscale.FieldStatus:
		v, ok := value.(upscale.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case upscale.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case upscale.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case upscale.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case upscale.FieldModelID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case upscale.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscale.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Upscale field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, upscale.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, upscale.FieldHeight)
	}
	if m.addscale != nil {
		fields = append(fields, upscale.FieldScale)
	}
	if m.addduration_ms != nil {
		fields = append(fields, upscale.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upscale.FieldWidth:
		return m.AddedWidth()
	case upscale.FieldHeight:
		return m.AddedHeight()
	case upscale.FieldScale:
		return m.AddedScale()
	case upscale.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upscale.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case upscale.FieldHeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case upscale.FieldScale:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScale(v)
		return nil
	case upscale.FieldDurationMs:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown Upscale numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upscale.FieldFailureReason) {
		fields = append(fields, upscale.FieldFailureReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleMutation) ClearField(name string) error {
	switch name {
	case upscale.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	}
	return fmt.Errorf("unknown Upscale nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleMutation) ResetField(name string) error {
	switch name {
	case upscale.FieldWidth:
		m.ResetWidth()
		return nil
	case upscale.FieldHeight:
		m.ResetHeight()
		return nil
	case upscale.FieldScale:
		m.ResetScale()
		return nil
	case upscale.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case upscale.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case upscale.FieldStatus:
		m.ResetStatus()
		return nil
	case upscale.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case upscale.FieldUserID:
		m.ResetUserID()
		return nil
	case upscale.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case upscale.FieldModelID:
		m.ResetModelID()
		return nil
	case upscale.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscale.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Upscale field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, upscale.EdgeUser)
	}
	if m.device_info != nil {
		edges = append(edges, upscale.EdgeDeviceInfo)
	}
	if m.upscale_models != nil {
		edges = append(edges, upscale.EdgeUpscaleModels)
	}
	if m.upscale_outputs != nil {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscale.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeUpscaleModels:
		if id := m.upscale_models; id != nil {
			return []ent.Value{*id}
		}
	case upscale.EdgeUpscaleOutputs:
		ids := make([]ent.Value, 0, len(m.upscale_outputs))
		for id := range m.upscale_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedupscale_outputs != nil {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upscale.EdgeUpscaleOutputs:
		ids := make([]ent.Value, 0, len(m.removedupscale_outputs))
		for id := range m.removedupscale_outputs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, upscale.EdgeUser)
	}
	if m.cleareddevice_info {
		edges = append(edges, upscale.EdgeDeviceInfo)
	}
	if m.clearedupscale_models {
		edges = append(edges, upscale.EdgeUpscaleModels)
	}
	if m.clearedupscale_outputs {
		edges = append(edges, upscale.EdgeUpscaleOutputs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleMutation) EdgeCleared(name string) bool {
	switch name {
	case upscale.EdgeUser:
		return m.cleareduser
	case upscale.EdgeDeviceInfo:
		return m.cleareddevice_info
	case upscale.EdgeUpscaleModels:
		return m.clearedupscale_models
	case upscale.EdgeUpscaleOutputs:
		return m.clearedupscale_outputs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleMutation) ClearEdge(name string) error {
	switch name {
	case upscale.EdgeUser:
		m.ClearUser()
		return nil
	case upscale.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case upscale.EdgeUpscaleModels:
		m.ClearUpscaleModels()
		return nil
	}
	return fmt.Errorf("unknown Upscale unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleMutation) ResetEdge(name string) error {
	switch name {
	case upscale.EdgeUser:
		m.ResetUser()
		return nil
	case upscale.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case upscale.EdgeUpscaleModels:
		m.ResetUpscaleModels()
		return nil
	case upscale.EdgeUpscaleOutputs:
		m.ResetUpscaleOutputs()
		return nil
	}
	return fmt.Errorf("unknown Upscale edge %s", name)
}

// UpscaleModelMutation represents an operation that mutates the UpscaleModel nodes in the graph.
type UpscaleModelMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	is_free         *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	upscales        map[uuid.UUID]struct{}
	removedupscales map[uuid.UUID]struct{}
	clearedupscales bool
	done            bool
	oldValue        func(context.Context) (*UpscaleModel, error)
	predicates      []predicate.UpscaleModel
}

var _ ent.Mutation = (*UpscaleModelMutation)(nil)

// upscalemodelOption allows management of the mutation configuration using functional options.
type upscalemodelOption func(*UpscaleModelMutation)

// newUpscaleModelMutation creates new mutation for the UpscaleModel entity.
func newUpscaleModelMutation(c config, op Op, opts ...upscalemodelOption) *UpscaleModelMutation {
	m := &UpscaleModelMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscaleModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleModelID sets the ID field of the mutation.
func withUpscaleModelID(id uuid.UUID) upscalemodelOption {
	return func(m *UpscaleModelMutation) {
		var (
			err   error
			once  sync.Once
			value *UpscaleModel
		)
		m.oldValue = func(ctx context.Context) (*UpscaleModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpscaleModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscaleModel sets the old UpscaleModel of the mutation.
func withUpscaleModel(node *UpscaleModel) upscalemodelOption {
	return func(m *UpscaleModelMutation) {
		m.oldValue = func(context.Context) (*UpscaleModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpscaleModel entities.
func (m *UpscaleModelMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleModelMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleModelMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpscaleModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UpscaleModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpscaleModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpscaleModelMutation) ResetName() {
	m.name = nil
}

// SetIsFree sets the "is_free" field.
func (m *UpscaleModelMutation) SetIsFree(b bool) {
	m.is_free = &b
}

// IsFree returns the value of the "is_free" field in the mutation.
func (m *UpscaleModelMutation) IsFree() (r bool, exists bool) {
	v := m.is_free
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFree returns the old "is_free" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldIsFree(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFree: %w", err)
	}
	return oldValue.IsFree, nil
}

// ResetIsFree resets all changes to the "is_free" field.
func (m *UpscaleModelMutation) ResetIsFree() {
	m.is_free = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpscaleModel entity.
// If the UpscaleModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *UpscaleModelMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UpscaleModelMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UpscaleModelMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *UpscaleModelMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *UpscaleModelMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *UpscaleModelMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UpscaleModelMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// Where appends a list predicates to the UpscaleModelMutation builder.
func (m *UpscaleModelMutation) Where(ps ...predicate.UpscaleModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpscaleModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpscaleModel).
func (m *UpscaleModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleModelMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, upscalemodel.FieldName)
	}
	if m.is_free != nil {
		fields = append(fields, upscalemodel.FieldIsFree)
	}
	if m.created_at != nil {
		fields = append(fields, upscalemodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscalemodel.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscalemodel.FieldName:
		return m.Name()
	case upscalemodel.FieldIsFree:
		return m.IsFree()
	case upscalemodel.FieldCreatedAt:
		return m.CreatedAt()
	case upscalemodel.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscalemodel.FieldName:
		return m.OldName(ctx)
	case upscalemodel.FieldIsFree:
		return m.OldIsFree(ctx)
	case upscalemodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscalemodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpscaleModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscalemodel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upscalemodel.FieldIsFree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFree(v)
		return nil
	case upscalemodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscalemodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UpscaleModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleModelMutation) ResetField(name string) error {
	switch name {
	case upscalemodel.FieldName:
		m.ResetName()
		return nil
	case upscalemodel.FieldIsFree:
		m.ResetIsFree()
		return nil
	case upscalemodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscalemodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.upscales != nil {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscalemodel.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedupscales != nil {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upscalemodel.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedupscales {
		edges = append(edges, upscalemodel.EdgeUpscales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleModelMutation) EdgeCleared(name string) bool {
	switch name {
	case upscalemodel.EdgeUpscales:
		return m.clearedupscales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleModelMutation) ResetEdge(name string) error {
	switch name {
	case upscalemodel.EdgeUpscales:
		m.ResetUpscales()
		return nil
	}
	return fmt.Errorf("unknown UpscaleModel edge %s", name)
}

// UpscaleOutputMutation represents an operation that mutates the UpscaleOutput nodes in the graph.
type UpscaleOutputMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	image_url       *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	upscales        *uuid.UUID
	clearedupscales bool
	done            bool
	oldValue        func(context.Context) (*UpscaleOutput, error)
	predicates      []predicate.UpscaleOutput
}

var _ ent.Mutation = (*UpscaleOutputMutation)(nil)

// upscaleoutputOption allows management of the mutation configuration using functional options.
type upscaleoutputOption func(*UpscaleOutputMutation)

// newUpscaleOutputMutation creates new mutation for the UpscaleOutput entity.
func newUpscaleOutputMutation(c config, op Op, opts ...upscaleoutputOption) *UpscaleOutputMutation {
	m := &UpscaleOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeUpscaleOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpscaleOutputID sets the ID field of the mutation.
func withUpscaleOutputID(id uuid.UUID) upscaleoutputOption {
	return func(m *UpscaleOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *UpscaleOutput
		)
		m.oldValue = func(ctx context.Context) (*UpscaleOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpscaleOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpscaleOutput sets the old UpscaleOutput of the mutation.
func withUpscaleOutput(node *UpscaleOutput) upscaleoutputOption {
	return func(m *UpscaleOutputMutation) {
		m.oldValue = func(context.Context) (*UpscaleOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpscaleOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpscaleOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpscaleOutput entities.
func (m *UpscaleOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpscaleOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpscaleOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpscaleOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImageURL sets the "image_url" field.
func (m *UpscaleOutputMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *UpscaleOutputMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *UpscaleOutputMutation) ResetImageURL() {
	m.image_url = nil
}

// SetUpscaleID sets the "upscale_id" field.
func (m *UpscaleOutputMutation) SetUpscaleID(u uuid.UUID) {
	m.upscales = &u
}

// UpscaleID returns the value of the "upscale_id" field in the mutation.
func (m *UpscaleOutputMutation) UpscaleID() (r uuid.UUID, exists bool) {
	v := m.upscales
	if v == nil {
		return
	}
	return *v, true
}

// OldUpscaleID returns the old "upscale_id" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldUpscaleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpscaleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpscaleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpscaleID: %w", err)
	}
	return oldValue.UpscaleID, nil
}

// ResetUpscaleID resets all changes to the "upscale_id" field.
func (m *UpscaleOutputMutation) ResetUpscaleID() {
	m.upscales = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UpscaleOutputMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpscaleOutputMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpscaleOutputMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpscaleOutputMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpscaleOutputMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpscaleOutput entity.
// If the UpscaleOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpscaleOutputMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpscaleOutputMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpscalesID sets the "upscales" edge to the Upscale entity by id.
func (m *UpscaleOutputMutation) SetUpscalesID(id uuid.UUID) {
	m.upscales = &id
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UpscaleOutputMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UpscaleOutputMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// UpscalesID returns the "upscales" edge ID in the mutation.
func (m *UpscaleOutputMutation) UpscalesID() (id uuid.UUID, exists bool) {
	if m.upscales != nil {
		return *m.upscales, true
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpscalesID instead. It exists only for internal usage by the builders.
func (m *UpscaleOutputMutation) UpscalesIDs() (ids []uuid.UUID) {
	if id := m.upscales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UpscaleOutputMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
}

// Where appends a list predicates to the UpscaleOutputMutation builder.
func (m *UpscaleOutputMutation) Where(ps ...predicate.UpscaleOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpscaleOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpscaleOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpscaleOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpscaleOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpscaleOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpscaleOutput).
func (m *UpscaleOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpscaleOutputMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.image_url != nil {
		fields = append(fields, upscaleoutput.FieldImageURL)
	}
	if m.upscales != nil {
		fields = append(fields, upscaleoutput.FieldUpscaleID)
	}
	if m.created_at != nil {
		fields = append(fields, upscaleoutput.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upscaleoutput.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpscaleOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upscaleoutput.FieldImageURL:
		return m.ImageURL()
	case upscaleoutput.FieldUpscaleID:
		return m.UpscaleID()
	case upscaleoutput.FieldCreatedAt:
		return m.CreatedAt()
	case upscaleoutput.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpscaleOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upscaleoutput.FieldImageURL:
		return m.OldImageURL(ctx)
	case upscaleoutput.FieldUpscaleID:
		return m.OldUpscaleID(ctx)
	case upscaleoutput.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upscaleoutput.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upscaleoutput.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case upscaleoutput.FieldUpscaleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpscaleID(v)
		return nil
	case upscaleoutput.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upscaleoutput.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpscaleOutputMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpscaleOutputMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpscaleOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpscaleOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpscaleOutputMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpscaleOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpscaleOutputMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UpscaleOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpscaleOutputMutation) ResetField(name string) error {
	switch name {
	case upscaleoutput.FieldImageURL:
		m.ResetImageURL()
		return nil
	case upscaleoutput.FieldUpscaleID:
		m.ResetUpscaleID()
		return nil
	case upscaleoutput.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upscaleoutput.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpscaleOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.upscales != nil {
		edges = append(edges, upscaleoutput.EdgeUpscales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpscaleOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upscaleoutput.EdgeUpscales:
		if id := m.upscales; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpscaleOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpscaleOutputMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpscaleOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedupscales {
		edges = append(edges, upscaleoutput.EdgeUpscales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpscaleOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case upscaleoutput.EdgeUpscales:
		return m.clearedupscales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpscaleOutputMutation) ClearEdge(name string) error {
	switch name {
	case upscaleoutput.EdgeUpscales:
		m.ClearUpscales()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpscaleOutputMutation) ResetEdge(name string) error {
	switch name {
	case upscaleoutput.EdgeUpscales:
		m.ResetUpscales()
		return nil
	}
	return fmt.Errorf("unknown UpscaleOutput edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	email                *string
	stripe_customer_id   *string
	created_at           *time.Time
	updated_at           *time.Time
	confirmed_at         *time.Time
	clearedFields        map[string]struct{}
	user_roles           map[uuid.UUID]struct{}
	removeduser_roles    map[uuid.UUID]struct{}
	cleareduser_roles    bool
	generations          map[uuid.UUID]struct{}
	removedgenerations   map[uuid.UUID]struct{}
	clearedgenerations   bool
	upscales             map[uuid.UUID]struct{}
	removedupscales      map[uuid.UUID]struct{}
	clearedupscales      bool
	subscriptions        *uuid.UUID
	clearedsubscriptions bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *UserMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[user.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *UserMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[user.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, user.FieldStripeCustomerID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetConfirmedAt sets the "confirmed_at" field.
func (m *UserMutation) SetConfirmedAt(t time.Time) {
	m.confirmed_at = &t
}

// ConfirmedAt returns the value of the "confirmed_at" field in the mutation.
func (m *UserMutation) ConfirmedAt() (r time.Time, exists bool) {
	v := m.confirmed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedAt returns the old "confirmed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConfirmedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedAt: %w", err)
	}
	return oldValue.ConfirmedAt, nil
}

// ClearConfirmedAt clears the value of the "confirmed_at" field.
func (m *UserMutation) ClearConfirmedAt() {
	m.confirmed_at = nil
	m.clearedFields[user.FieldConfirmedAt] = struct{}{}
}

// ConfirmedAtCleared returns if the "confirmed_at" field was cleared in this mutation.
func (m *UserMutation) ConfirmedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldConfirmedAt]
	return ok
}

// ResetConfirmedAt resets all changes to the "confirmed_at" field.
func (m *UserMutation) ResetConfirmedAt() {
	m.confirmed_at = nil
	delete(m.clearedFields, user.FieldConfirmedAt)
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *UserMutation) AddUserRoleIDs(ids ...uuid.UUID) {
	if m.user_roles == nil {
		m.user_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *UserMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *UserMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveUserRoleIDs(ids ...uuid.UUID) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *UserMutation) RemovedUserRolesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *UserMutation) UserRolesIDs() (ids []uuid.UUID) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *UserMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddGenerationIDs adds the "generations" edge to the Generation entity by ids.
func (m *UserMutation) AddGenerationIDs(ids ...uuid.UUID) {
	if m.generations == nil {
		m.generations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.generations[ids[i]] = struct{}{}
	}
}

// ClearGenerations clears the "generations" edge to the Generation entity.
func (m *UserMutation) ClearGenerations() {
	m.clearedgenerations = true
}

// GenerationsCleared reports if the "generations" edge to the Generation entity was cleared.
func (m *UserMutation) GenerationsCleared() bool {
	return m.clearedgenerations
}

// RemoveGenerationIDs removes the "generations" edge to the Generation entity by IDs.
func (m *UserMutation) RemoveGenerationIDs(ids ...uuid.UUID) {
	if m.removedgenerations == nil {
		m.removedgenerations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.generations, ids[i])
		m.removedgenerations[ids[i]] = struct{}{}
	}
}

// RemovedGenerations returns the removed IDs of the "generations" edge to the Generation entity.
func (m *UserMutation) RemovedGenerationsIDs() (ids []uuid.UUID) {
	for id := range m.removedgenerations {
		ids = append(ids, id)
	}
	return
}

// GenerationsIDs returns the "generations" edge IDs in the mutation.
func (m *UserMutation) GenerationsIDs() (ids []uuid.UUID) {
	for id := range m.generations {
		ids = append(ids, id)
	}
	return
}

// ResetGenerations resets all changes to the "generations" edge.
func (m *UserMutation) ResetGenerations() {
	m.generations = nil
	m.clearedgenerations = false
	m.removedgenerations = nil
}

// AddUpscaleIDs adds the "upscales" edge to the Upscale entity by ids.
func (m *UserMutation) AddUpscaleIDs(ids ...uuid.UUID) {
	if m.upscales == nil {
		m.upscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.upscales[ids[i]] = struct{}{}
	}
}

// ClearUpscales clears the "upscales" edge to the Upscale entity.
func (m *UserMutation) ClearUpscales() {
	m.clearedupscales = true
}

// UpscalesCleared reports if the "upscales" edge to the Upscale entity was cleared.
func (m *UserMutation) UpscalesCleared() bool {
	return m.clearedupscales
}

// RemoveUpscaleIDs removes the "upscales" edge to the Upscale entity by IDs.
func (m *UserMutation) RemoveUpscaleIDs(ids ...uuid.UUID) {
	if m.removedupscales == nil {
		m.removedupscales = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.upscales, ids[i])
		m.removedupscales[ids[i]] = struct{}{}
	}
}

// RemovedUpscales returns the removed IDs of the "upscales" edge to the Upscale entity.
func (m *UserMutation) RemovedUpscalesIDs() (ids []uuid.UUID) {
	for id := range m.removedupscales {
		ids = append(ids, id)
	}
	return
}

// UpscalesIDs returns the "upscales" edge IDs in the mutation.
func (m *UserMutation) UpscalesIDs() (ids []uuid.UUID) {
	for id := range m.upscales {
		ids = append(ids, id)
	}
	return
}

// ResetUpscales resets all changes to the "upscales" edge.
func (m *UserMutation) ResetUpscales() {
	m.upscales = nil
	m.clearedupscales = false
	m.removedupscales = nil
}

// SetSubscriptionsID sets the "subscriptions" edge to the Subscription entity by id.
func (m *UserMutation) SetSubscriptionsID(id uuid.UUID) {
	m.subscriptions = &id
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// SubscriptionsID returns the "subscriptions" edge ID in the mutation.
func (m *UserMutation) SubscriptionsID() (id uuid.UUID, exists bool) {
	if m.subscriptions != nil {
		return *m.subscriptions, true
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SubscriptionsIDs() (ids []uuid.UUID) {
	if id := m.subscriptions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.confirmed_at != nil {
		fields = append(fields, user.FieldConfirmedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldConfirmedAt:
		return m.ConfirmedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldConfirmedAt:
		return m.OldConfirmedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldConfirmedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStripeCustomerID) {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.FieldCleared(user.FieldConfirmedAt) {
		fields = append(fields, user.FieldConfirmedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case user.FieldConfirmedAt:
		m.ClearConfirmedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldConfirmedAt:
		m.ResetConfirmedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.generations != nil {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.upscales != nil {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.generations))
		for id := range m.generations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.upscales))
		for id := range m.upscales {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		if id := m.subscriptions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser_roles != nil {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.removedgenerations != nil {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.removedupscales != nil {
		edges = append(edges, user.EdgeUpscales)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGenerations:
		ids := make([]ent.Value, 0, len(m.removedgenerations))
		for id := range m.removedgenerations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpscales:
		ids := make([]ent.Value, 0, len(m.removedupscales))
		for id := range m.removedupscales {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser_roles {
		edges = append(edges, user.EdgeUserRoles)
	}
	if m.clearedgenerations {
		edges = append(edges, user.EdgeGenerations)
	}
	if m.clearedupscales {
		edges = append(edges, user.EdgeUpscales)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserRoles:
		return m.cleareduser_roles
	case user.EdgeGenerations:
		return m.clearedgenerations
	case user.EdgeUpscales:
		return m.clearedupscales
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeSubscriptions:
		m.ClearSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case user.EdgeGenerations:
		m.ResetGenerations()
		return nil
	case user.EdgeUpscales:
		m.ResetUpscales()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	role_name     *userrole.RoleName
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	users         *uuid.UUID
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id uuid.UUID) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRole entities.
func (m *UserRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(u uuid.UUID) {
	m.users = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.users = nil
}

// SetRoleName sets the "role_name" field.
func (m *UserRoleMutation) SetRoleName(un userrole.RoleName) {
	m.role_name = &un
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *UserRoleMutation) RoleName() (r userrole.RoleName, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleName(ctx context.Context) (v userrole.RoleName, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *UserRoleMutation) ResetRoleName() {
	m.role_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *UserRoleMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UserRoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UserRoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *UserRoleMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserRoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.users != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	if m.role_name != nil {
		fields = append(fields, userrole.FieldRoleName)
	}
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldUserID:
		return m.UserID()
	case userrole.FieldRoleName:
		return m.RoleName()
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrole.FieldRoleName:
		return m.OldRoleName(ctx)
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrole.FieldRoleName:
		v, ok := value.(userrole.RoleName)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrole.FieldRoleName:
		m.ResetRoleName()
		return nil
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, userrole.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, userrole.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
